[{"id":"n8n","user_id":"697d114c-1976-45d8-b1e0-0c2e306c453c","name":"n8n","type":"pipe","content":"\"\"\"\ntitle: n8n long running workflow pipe\nauthor: Marc Emmanuel\ndescription: Attach n8n avoiding timeouts\nversion: 0.1.0\nlicense: MIT\n\"\"\"\n\nimport json\nimport time\nimport httpx\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, List, Callable, Awaitable, AsyncGenerator\nimport asyncio\n\n\nclass Pipe:\n    class Valves(BaseModel):\n        N8N_WEBHOOK: str = Field(\n            default=\"https://[your domain].app.n8n.cloud/webhook/...\",\n            description=\"Base URL\",\n        )\n        N8N_SECRET: str = Field(\n            default=\"...\",\n            description=\"Secret to secure n8n endpoint\",\n        )\n        CHECK_INTERVAL: int = Field(\n            default=5,\n            description=\"Interval in seconds to check for task completion\",\n        )\n        MAX_CHECKS: int = Field(\n            default=60,\n            description=\"Maximum number of status checks before giving up\",\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.id = \"n8n\"\n        self.type = \"manifold\"\n        self.name = \"[Agent Name]\"\n        self.description = \"[Agent Role]\"\n        self.emitter = None\n\n    async def pipe(\n        self,\n        body: dict,\n        __chat_id__: str,\n        __files__: Optional[Any],\n        __event_emitter__: Optional[Callable[[Dict[str, Any]], Awaitable[None]]] = None,\n    ) -> AsyncGenerator[str, None]:\n        self.emitter = __event_emitter__\n\n        # Extract the last user message to use as prompt\n        last_user_message = self._get_last_user_message(body.get(\"messages\", []))\n\n        if not last_user_message:\n            yield json.dumps({\"error\": \"No user message found\"}, ensure_ascii=False)\n            return\n\n        try:\n            # Send status update\n            await self._emit_status(\"Sending your request...\")\n\n            # Prepare request parameters\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"x-secret\": f\"{self.valves.N8N_SECRET}\",\n            }\n\n            payload = {\n                \"chatInput\": f\"{last_user_message}\",\n                \"session_id\": f\"{__chat_id__}\",\n                \"files\": __files__,\n            }\n\n            # Start answering\n            async with httpx.AsyncClient() as client:\n                initialResponse = await client.post(\n                    f\"{self.valves.N8N_WEBHOOK}\",\n                    json=payload,\n                    headers=headers,\n                )\n\n                if initialResponse.status_code != 200:\n                    yield json.dumps(\n                        {\n                            \"error\": f\"There was an issue talking to Sara: {initialResponse.text}\"\n                        },\n                        ensure_ascii=False,\n                    )\n                    return\n\n                execution_data = initialResponse.json()\n                execution_id = execution_data.get(\"executionId\")\n\n                if not execution_id:\n                    yield json.dumps(\n                        {\"error\": \"No execution ID received from n8n\"},\n                        ensure_ascii=False,\n                    )\n                    return\n\n                # Notify user that composition has started\n                yield f\"Thanks for your request. I will immediately start working on it.\\n\"\n                # yield f\"Task ID: `{execution_id}`\\n\\n\"\n                yield f\"Please be patient...\\n\"\n\n                # Poll for completion\n                check_count = 0\n                finished = False\n                answer = \"\"\n\n                while finished != True and check_count < self.valves.MAX_CHECKS:\n                    check_count += 1\n\n                    # Wait before checking\n                    await asyncio.sleep(self.valves.CHECK_INTERVAL)\n                    await self._emit_status(\n                        f\"Checking progress... (Attempt {check_count})\"\n                    )\n\n                    # Check status\n                    status_response = await client.get(\n                        f\"{self.valves.N8N_WEBHOOK}?executionId={execution_id}\",\n                        headers=headers,\n                    )\n\n                    if status_response.status_code != 200:\n                        yield json.dumps(\n                            {\"error\": f\"Error checking status: {status_response.text}\"},\n                            ensure_ascii=False,\n                        )\n                        return\n\n                    execution_status = status_response.json()\n                    finished = execution_status.get(\"finished\", \"unknown\")\n                    answer = execution_status.get(\"message\", \"unknown\")\n\n                    await self._emit_status(\n                        f\"Still not done. Checking back in {self.valves.CHECK_INTERVAL} seconds...\"\n                    )\n\n                # Final results\n                if finished and answer != \"\":\n                    yield f\"{answer}\"\n\n                elif check_count >= self.valves.MAX_CHECKS:\n                    yield f\"⚠️ Timed out waiting for your answer to complete. You can check the status later with task ID: `{task_id}`\\n\"\n                else:\n                    yield f\"❌ Answer failed or encountered an error. For support use the task ID: `{execution_id}\\n\"\n\n                # Final status update\n                await self._emit_status(\"\", done=True)\n\n        except Exception as e:\n            yield json.dumps(\n                {\"error\": f\"An error occurred: {str(e)}\"}, ensure_ascii=False\n            )\n            await self._emit_status(f\"Error: {str(e)}\", done=True)\n\n    def _get_last_user_message(self, messages):\n        \"\"\"Extract the last user message from the conversation\"\"\"\n        for message in reversed(messages):\n            if message.get(\"role\") == \"user\":\n                content = message.get(\"content\")\n                if isinstance(content, str):\n                    return content\n                elif isinstance(content, list):\n                    # Handle content that might be a list of parts\n                    for part in content:\n                        if part.get(\"type\") == \"text\":\n                            return part.get(\"text\", \"\")\n        return \"\"\n\n    async def _emit_status(\n        self, description: str, done: bool = False\n    ) -> Awaitable[None]:\n        \"\"\"Send status updates\"\"\"\n        if self.emitter:\n            return await self.emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n        return None\n","meta":{"description":"Pipe to access n8n workflows","manifest":{"title":"n8n long running workflow pipe","author":"Marc Emmanuel","description":"Attach n8n avoiding timeouts","version":"0.1.0","license":"MIT"}},"is_active":false,"is_global":false,"updated_at":1754666885,"created_at":1753861657}]